type Approval @entity(immutable: true) {
  id: Bytes!
  owner: Bytes! # address
  approved: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ApprovalForAll @entity(immutable: true) {
  id: Bytes!
  owner: Bytes! # address
  operator: Bytes! # address
  approved: Boolean! # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DelegateChanged @entity(immutable: true) {
  id: Bytes!
  delegator: Bytes! # address
  fromDelegate: Bytes! # address
  toDelegate: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DelegateVotesChanged @entity(immutable: true) {
  id: Bytes!
  delegate: Bytes! # address
  previousBalance: BigInt! # uint256
  newBalance: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DescriptorLocked @entity(immutable: true) {
  id: Bytes!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DescriptorUpdated @entity(immutable: true) {
  id: Bytes!
  descriptor: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MinterLocked @entity(immutable: true) {
  id: Bytes!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MinterUpdated @entity(immutable: true) {
  id: Bytes!
  minter: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NounBurned @entity(immutable: true) {
  id: Bytes!
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NounCreated @entity(immutable: true) {
  id: Bytes!
  tokenId: BigInt! # uint256
  seed_background: BigInt! # uint48
  seed_body: BigInt! # uint48
  seed_accessory: BigInt! # uint48
  seed_head: BigInt! # uint48
  seed_glasses: BigInt! # uint48
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NoundersDAOUpdated @entity(immutable: true) {
  id: Bytes!
  noundersDAO: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type OwnershipTransferred @entity(immutable: true) {
  id: Bytes!
  previousOwner: Bytes! # address
  newOwner: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type SeederLocked @entity(immutable: true) {
  id: Bytes!

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type SeederUpdated @entity(immutable: true) {
  id: Bytes!
  seeder: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Transfer @entity(immutable: true) {
  id: Bytes!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
type AdminChanged @entity(immutable: true) {
  id: Bytes!
  previousAdmin: Bytes! # address
  newAdmin: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type BeaconUpgraded @entity(immutable: true) {
  id: Bytes!
  beacon: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DroposalTypeApproved @entity(immutable: true) {
  id: Bytes!
  droposalTypeId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DroposalTypeProposed @entity(immutable: true) {
  id: Bytes!
  droposalTypeId: BigInt! # uint256
  config_name: String! # string
  config_editionSize: BigInt! # uint64
  config_publicSalePrice: BigInt! # uint96
  config_publicSaleDuration: BigInt! # uint64
  config_fundsRecipientSplit: BigInt! # uint32
  config_minter: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DroposalTypeSet @entity(immutable: true) {
  id: Bytes!
  droposalTypeId: BigInt! # uint256
  config_name: String! # string
  config_editionSize: BigInt! # uint64
  config_publicSalePrice: BigInt! # uint96
  config_publicSaleDuration: BigInt! # uint64
  config_fundsRecipientSplit: BigInt! # uint32
  config_minter: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Initialized @entity(immutable: true) {
  id: Bytes!
  version: Int! # uint8
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NounsAgoraGovernorSepoliaOwnershipTransferred @entity(immutable: true) {
  id: Bytes!
  previousOwner: Bytes! # address
  newOwner: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ProposalCanceled @entity(immutable: true) {
  id: Bytes!
  proposalId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ProposalCreated @entity(immutable: true) {
  id: Bytes!
  proposalId: BigInt! # uint256
  proposer: Bytes! # address
  targets: [Bytes!]! # address[]
  values: [BigInt!]! # uint256[]
  signatures: [String!]! # string[]
  calldatas: [Bytes!]! # bytes[]
  startBlock: BigInt! # uint256
  endBlock: BigInt! # uint256
  description: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ProposalExecuted @entity(immutable: true) {
  id: Bytes!
  proposalId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ProposalThresholdSet @entity(immutable: true) {
  id: Bytes!
  oldProposalThreshold: BigInt! # uint256
  newProposalThreshold: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Upgraded @entity(immutable: true) {
  id: Bytes!
  implementation: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type VoteCast @entity(immutable: true) {
  id: Bytes!
  voter: Bytes! # address
  proposalId: BigInt! # uint256
  support: Int! # uint8
  weight: BigInt! # uint256
  reason: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type VoteCastWithParams @entity(immutable: true) {
  id: Bytes!
  voter: Bytes! # address
  proposalId: BigInt! # uint256
  support: Int! # uint8
  weight: BigInt! # uint256
  reason: String! # string
  params: Bytes! # bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type VotingDelaySet @entity(immutable: true) {
  id: Bytes!
  oldVotingDelay: BigInt! # uint256
  newVotingDelay: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type VotingPeriodSet @entity(immutable: true) {
  id: Bytes!
  oldVotingPeriod: BigInt! # uint256
  newVotingPeriod: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DelegateChange @entity(immutable: true) {
  "Unique entity used to keep track of delegate changes"
  id: ID!
  "Token address"
  tokenAddress: String!
  "Address for delegator"
  delegator: String!
  "Address for delegate"
  delegate: String!
  "Address for previous delegate"
  previousDelegate: String!
  "Block time change happened"
  blockTimestamp: BigInt!
  "Transaction hash of the delegate change event"
  txnHash: String!
  "Log index for delegate change"
  logIndex: BigInt!
  "Block number of event"
  blockNumber: BigInt!
}

type DelegateVotingPowerChange @entity(immutable: true) {
  "Unique entity used to keep track of voting power delta"
  id: ID!
  "Token addresss"
  tokenAddress: String!
  "Address for delegate"
  delegate: String!
  "Previous voting power of delegate"
  previousBalance: BigInt!
  "New voting power of delegate"
  newBalance: BigInt!
  "Block time change happened"
  blockTimestamp: BigInt!
  "Transaction hash of the voting power change"
  txnHash: String!
  "Log index for delegate voting power change"
  logIndex: BigInt!
  "Block number of event"
  blockNumber: BigInt!
}

type Governance @entity {
  "Unique entity used to keep track of common aggregated data"
  id: ID!

  "Total Supply of token"
  totalTokenSupply: BigInt!
  "Total number of token holders currently"
  currentTokenHolders: BigInt!
  "Total number of token holders"
  totalTokenHolders: BigInt!
  "Total number of delegates participating on the governance currently"
  currentDelegates: BigInt!
  "Total number of delegates that held delegated votes"
  totalDelegates: BigInt!
  "Total number of votes delegated expressed in the smallest unit of the token"
  delegatedVotesRaw: BigInt!
  "Total number of votes delegated expressed as a BigDecimal normalized value for the token"
  delegatedVotes: BigDecimal!

  "Total number of proposals created"
  proposals: BigInt!
  "Number of proposals currently queued for execution"
  proposalsQueued: BigInt!
  "Number of proposals currently executed"
  proposalsExecuted: BigInt!
  "Number of proposals currently canceled"
  proposalsCanceled: BigInt!
}

type GovernanceFramework @entity {
  "Governance framework contract address"
  id: String!
  "Name of the governance framework"
  name: String!
  "Type of governance framework"
  type: GovernanceFrameworkType!
  "Version of the governance framework"
  version: String!

  "Governance framework contract address"
  contractAddress: String!
  "The contract address associated with the governance token used for voting on the governance framework proposals"
  tokenAddress: String!
  "The contract address associated with the contract that manages the delay of administrative actions for the governance framework"
  timelockAddress: String!

  "The delay before voting on a proposal may take place in blocks"
  votingDelay: BigInt!
  "The duration of voting on a proposal in blocks"
  votingPeriod: BigInt!
  "The number of votes required in order for a voter to become a proposer"
  proposalThreshold: BigInt!

  "The number of votes for a proposal to succeed."
  quorumVotes: BigInt
  "Quorum fraction numerator value. (OZ: quorum = totalSupply * numerator / denominator)"
  quorumNumerator: BigInt
  "Quorum fraction denominator value. (OZ: quorum = totalSupply * numerator / denominator)"
  quorumDenominator: BigInt
}

enum GovernanceFrameworkType {
  GovernorAlpha
  GovernorBravo
  OZGovernor
  AaveGovernanceV2
}

type Proposal @entity {
  "Internal proposal ID, in this implementation it seems to be a autoincremental id"
  id: ID!
  "Transaction hash of the proposal creation"
  txnHash: String!
  "Proposal description in markdown format"
  description: String!

  "Delegate that proposed the proposal"
  proposer: Delegate!
  "State of the proposal"
  state: ProposalState!
  "The number of votes for a proposal to succeed."
  quorumVotes: BigInt!
  "Number of tokenholders at start of voting"
  tokenHoldersAtStart: BigInt!
  "Number of delegates at start of voting"
  delegatesAtStart: BigInt!

  "Number of delegates that voted against the proposal"
  againstDelegateVotes: BigInt!
  "Number of delegates that voted for the proposal"
  forDelegateVotes: BigInt!
  "Number of delegates that voted abstain to the proposal"
  abstainDelegateVotes: BigInt!
  "Total number of delegates that voted on the proposal"
  totalDelegateVotes: BigInt!

  "Weighted votes against the proposal"
  againstWeightedVotes: BigInt!
  "Weighted votes for the proposal"
  forWeightedVotes: BigInt!
  "Weighted votes abstaining to the proposal"
  abstainWeightedVotes: BigInt!
  "Total weighted for/against/abstaining votes"
  totalWeightedVotes: BigInt!

  "Votes associated to this proposal"
  votes: [Vote!]! @derivedFrom(field: "proposal")

  "Block number proposal was created in"
  creationBlock: BigInt!
  "Timestamp of block proposal was created in"
  creationTime: BigInt!
  "Block number from where the voting starts"
  startBlock: BigInt!
  "Block number from where the voting ends"
  endBlock: BigInt!
  "Transaction hash of the proposal being queued"
  queueTxnHash: String
  "Block number proposal was queued in"
  queueBlock: BigInt
  "Timestamp of block proposal was queued in"
  queueTime: BigInt
  "Once the proposal is queued for execution it will have an ETA of the execution"
  executionETA: BigInt
  "Transaction hash of the proposal execution"
  executionTxnHash: String
  "Block number proposal was executed in"
  executionBlock: BigInt
  "Timestamp of block proposal was executed in"
  executionTime: BigInt
  "Transaction hash of the proposal cancellation"
  cancellationTxnHash: String
  "Block number proposal was canceled in"
  cancellationBlock: BigInt
  "Timestamp of block proposal was canceled in"
  cancellationTime: BigInt

  "Targets data for the change"
  targets: [String!]
  "Values data for the change"
  values: [BigInt!]
  "Signature data for the change"
  signatures: [String!]
  "Call data for the change"
  calldatas: [Bytes!]
}

enum ProposalState {
  PENDING
  ACTIVE
  CANCELED
  DEFEATED
  SUCCEEDED
  QUEUED
  EXPIRED
  EXECUTED
}

type Vote @entity(immutable: true) {
  "Delegate ID + Proposal ID"
  id: ID!
  "Whether the vote is in favour, against or abstaining to the proposal"
  choice: VoteChoice!
  "Voting weight expressed in the vote"
  weight: BigInt!
  "Reason for voting choice"
  reason: String
  "Delegate that emitted the vote"
  voter: Delegate!
  "Proposal that is being voted on"
  proposal: Proposal!

  "Block number vote is cast in"
  block: BigInt!
  "Timestamp of block vote was cast in"
  blockTime: BigInt!
  "Transaction hash of the vote"
  txnHash: String!
  "Log Index of the event"
  logIndex: BigInt!
  "Unique ID based on the blockTime and logIndex"
  blockTimeId: String!
}

enum VoteChoice {
  FOR
  AGAINST
  ABSTAIN
}

type TokenHolder @entity {
  "A TokenHolder is any address that holds any amount of tokens, the id used is the blockchain address."
  id: String!
  "Delegate address of the token holder which will participate in votings. Delegates don't need to hold any tokens and can even be the token holder itself."
  delegate: Delegate

  "Token balance of this address expressed in the smallest unit of the token"
  tokenBalanceRaw: BigInt!
  "Token balance of this address expressed as a BigDecimal normalized value"
  tokenBalance: BigDecimal!
  "Total amount of tokens ever held by this address expressed in the smallest unit of the token"
  totalTokensHeldRaw: BigInt!
  "Total amount of tokens ever held by this address expressed as a BigDecimal normalized value"
  totalTokensHeld: BigDecimal!
}

type Delegate @entity {
  "A Delegate is any address that has been delegated with voting tokens by a token holder, id is the blockchain address of said delegate"
  id: String!

  "Amount of votes delegated to this delegate to be used on proposal votings expressed in the smallest unit of the token"
  delegatedVotesRaw: BigInt!
  "Amount of votes delegated to this delegate to be used on proposal votings expressed as a BigDecimal normalized value"
  delegatedVotes: BigDecimal!

  "Total token holders that this delegate represents"
  tokenHoldersRepresentedAmount: Int!
  "Token holders that this delegate represents"
  tokenHoldersRepresented: [TokenHolder!]! @derivedFrom(field: "delegate")

  "Votes that a delegate has made in different proposals"
  votes: [Vote!]! @derivedFrom(field: "voter")
  "Number of proposals voted on"
  numberVotes: Int!

  "Proposals that the delegate has created"
  proposals: [Proposal!]! @derivedFrom(field: "proposer")
}

# Timeseries Data
type TokenDailySnapshot @entity {
  "Number of days from Unix epoch time"
  id: ID!
  "Total Supply at snapshot"
  totalSupply: BigInt!
  "Number of tokenholders at snapshot"
  tokenHolders: BigInt!
  "Number of delegates at snapshot"
  delegates: BigInt!
  "Block number of last block in snapshot"
  blockNumber: BigInt!
  "Timestamp of snapshot"
  timestamp: BigInt!
}

type VoteDailySnapshot @entity {
  "Number of days from Unix epoch time"
  id: ID!
  "Proposal this snapshot is associated with"
  proposal: Proposal!
  "Weighted votes against the proposal at snapshot"
  forWeightedVotes: BigInt!
  "Weighted votes abstaining to the proposal at snapshot"
  againstWeightedVotes: BigInt!
  "Weighted votes for the proposal at snapshot"
  abstainWeightedVotes: BigInt!
  "Total weighted for/against/abstaining votes at snapshot"
  totalWeightedVotes: BigInt!
  "Block number of last block in snapshot"
  blockNumber: BigInt!
  "Timestamp of snapshot"
  timestamp: BigInt!
}
